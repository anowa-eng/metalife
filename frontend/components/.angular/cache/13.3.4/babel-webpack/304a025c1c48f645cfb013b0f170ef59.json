{"ast":null,"code":"import _asyncToGenerator from \"/workspace/sympan/frontend/components/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { EventEmitter } from '@angular/core';\nimport { transformData } from './transform-data';\nimport _ from 'lodash';\nimport { findCollisionPoint } from './collision-point';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./room-data.service\";\nimport * as i2 from \"./../user-data.service\";\nimport * as i3 from \"./web-socket.service\";\nimport * as i4 from \"../window.service\";\nimport * as i5 from \"@angular/common\";\nconst _c0 = [\"roomView\"];\n\nfunction RoomViewComponent__svg_ng_container_2__svg_pattern_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"pattern\", 5);\n    i0.ɵɵelement(1, \"image\", 6);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const userProfile_r4 = ctx.$implicit;\n    i0.ɵɵpropertyInterpolate1(\"id\", \"pattern-user-\", userProfile_r4.userId, \"\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"href\", userProfile_r4.profile.avatar);\n  }\n}\n\nfunction RoomViewComponent__svg_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, RoomViewComponent__svg_ng_container_2__svg_pattern_1_Template, 2, 2, \"pattern\", 4);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.userProfiles);\n  }\n}\n\nfunction RoomViewComponent__svg_circle_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelement(0, \"circle\", 7);\n  }\n\n  if (rf & 2) {\n    const userInRoom_r5 = ctx.$implicit;\n    const ctx_r2 = i0.ɵɵnextContext();\n    let tmp_0_0;\n    let tmp_2_0;\n    i0.ɵɵattributeInterpolate1(\"fill\", \"url(#pattern-user-\", (tmp_0_0 = ctx_r2.getProfileById(userInRoom_r5)) == null ? null : tmp_0_0.userId, \")\");\n    i0.ɵɵattributeInterpolate3(\"transform\", \"rotate(\", userInRoom_r5.direction, \" \", userInRoom_r5.position.x, \" \", userInRoom_r5.position.y, \")\");\n    i0.ɵɵpropertyInterpolate1(\"id\", \"user-\", (tmp_2_0 = ctx_r2.getProfileById(userInRoom_r5)) == null ? null : tmp_2_0.userId, \"\");\n    i0.ɵɵattribute(\"r\", ctx_r2.circleRadius)(\"cx\", userInRoom_r5.position.x)(\"cy\", userInRoom_r5.position.y);\n  }\n}\n\nexport let RoomViewComponent = /*#__PURE__*/(() => {\n  class RoomViewComponent {\n    constructor(roomDataService, userDataService, webSocketService, windowService) {\n      this.roomDataService = roomDataService;\n      this.userDataService = userDataService;\n      this.webSocketService = webSocketService;\n      this.windowService = windowService;\n      this.data = [];\n      this.localUser = {\n        position: {\n          x: 0,\n          y: 0\n        },\n        direction: 0,\n        velocity: 0,\n        angularVelocity: 0,\n        drag: 0,\n        angularDrag: 0,\n        id: 1,\n        hist: {\n          prevPosition: null,\n          prevDirection: null\n        }\n      };\n      this._permittedKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp'];\n      this._keysDown = [];\n      this.changeEventEmitter = new EventEmitter();\n      this.frames = [];\n      this.shouldContinueAnimating = true;\n      this.circleRadius = 12.5;\n\n      this.refreshRoomView = () => {\n        this.updateVelocities();\n        this.updateDrags();\n        this.addDrags();\n        if (this.localUser.velocity || this.localUser.angularVelocity) this.updateLocalUser();\n        this.updateData();\n        this.frames.push(this.localUser.position);\n        this.emitChangeEvents();\n        if (this.shouldContinueAnimating) requestAnimationFrame(this.refreshRoomView);else cancelAnimationFrame(this.animationId);\n      };\n    }\n\n    onUnload() {\n      this.shouldContinueAnimating = false;\n    }\n\n    getDimensions() {\n      return this.windowService.getDimensions();\n    }\n\n    getCenterLocation() {\n      let dimensions = this.windowService.getDimensions();\n      let centerX = dimensions.width / 2;\n      let centerY = dimensions.height / 2;\n      return {\n        x: centerX,\n        y: centerY\n      };\n    }\n\n    loadProfiles() {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        var _a;\n\n        if (_this.data && _this.data.length) {\n          let ids = (_a = _this.data) === null || _a === void 0 ? void 0 : _a.map(user => user.user_id);\n\n          _this.userDataService.loadUserProfiles(ids).subscribe(profiles => {\n            _this.userProfiles = profiles;\n          });\n        }\n      })();\n    }\n\n    getProfileById(userInRoom) {\n      var _a;\n\n      let userId = userInRoom.user_id;\n      return (_a = this.userProfiles) === null || _a === void 0 ? void 0 : _a.find(user => user.userId == userId);\n    }\n\n    onKeyDown(event) {\n      let code = event.code;\n      if (this._permittedKeys.includes(code) && !this._keysDown.includes(code)) this._keysDown.push(code);\n    }\n\n    onKeyUp(event) {\n      let index = _.indexOf(this._keysDown, event.code);\n\n      delete this._keysDown[index];\n    }\n\n    _overlappingUserPixelsAt({\n      x,\n      y\n    }) {\n      var _a;\n\n      const diameter = this.circleRadius * 2;\n      let users = (_a = this.untransformedData) === null || _a === void 0 ? void 0 : _a.filter(user => user.user_id !== this.localUser.id);\n\n      if (users) {\n        function getDistanceFrom(pos) {\n          let coords = {\n            x: (pos.x - x) ** 2,\n            y: (pos.y - y) ** 2\n          };\n          let distance = Math.sqrt(coords.x + coords.y);\n          return distance;\n        }\n\n        let distances = {};\n\n        for (const user of users) {\n          distances[user.user_id] = getDistanceFrom(user.data.position);\n        }\n\n        let isTouchingUsers = {};\n\n        for (const pair of Object.entries(distances)) {\n          let userId = Number(pair[0]),\n              distance = pair[1];\n          isTouchingUsers[userId] = distance < diameter;\n        }\n\n        return isTouchingUsers;\n      }\n    }\n\n    userTouchedAt({\n      x,\n      y\n    }) {\n      let usersTouched = this._overlappingUserPixelsAt({\n        x,\n        y\n      });\n\n      var userIds = Object.keys(usersTouched || {}).filter(k => usersTouched[k]).map(userId => Number(userId))[0];\n      return userIds;\n    }\n\n    updateVelocities() {\n      let newVelocity, newAngularVelocity;\n\n      if (this._keysDown.includes('ArrowUp')) {\n        newVelocity = this.localUser.velocity + 0.046875;\n        this.localUser.velocity = newVelocity;\n      }\n\n      if (this._keysDown.includes('ArrowLeft')) {\n        newAngularVelocity = this.localUser.angularVelocity - 0.0234375;\n        this.localUser.angularVelocity = newAngularVelocity;\n      }\n\n      if (this._keysDown.includes('ArrowRight')) {\n        newAngularVelocity = this.localUser.angularVelocity + 0.0234375;\n        this.localUser.angularVelocity = newAngularVelocity;\n      }\n    }\n\n    emitChangeEvents() {\n      var _a, _b;\n\n      let currentPosition = this.localUser.position,\n          prevPosition = this.localUser.hist.prevPosition,\n          currentDirection = this.localUser.direction,\n          prevDirection = this.localUser.hist.prevDirection;\n      if (!_.isEqual(currentPosition, prevPosition)) (_a = this.changeEventEmitter) === null || _a === void 0 ? void 0 : _a.emit('positionChange');\n      if (currentDirection !== prevDirection) (_b = this.changeEventEmitter) === null || _b === void 0 ? void 0 : _b.emit('directionChange');\n    }\n\n    moved() {\n      return !_.isEqual(this.localUser.position, this.localUser.hist.prevPosition);\n    }\n\n    updateLocalUser() {\n      let newPosition = {\n        y: this.localUser.position.y + Math.sin((this.localUser.direction - 90) * (Math.PI / 180)) * this.localUser.velocity,\n        x: this.localUser.position.x + Math.cos((this.localUser.direction - 90) * (Math.PI / 180)) * this.localUser.velocity\n      };\n      this.localUser.hist.prevPosition = Object.assign({}, this.localUser.position);\n      this.localUser.hist.prevDirection = this.localUser.direction;\n      let idOfCollidedUser = this.userTouchedAt(newPosition);\n\n      if (idOfCollidedUser) {\n        this.localUserOnCollidedUpdate(idOfCollidedUser, newPosition);\n      } else {\n        this.localUser.position = newPosition;\n      }\n\n      this.localUser.direction += this.localUser.angularVelocity;\n    }\n\n    localUserOnCollidedUpdate(idOfCollidedUser, newPosition) {\n      var _a;\n\n      let collidedUser = (_a = this.untransformedData) === null || _a === void 0 ? void 0 : _a.find(user => user.user_id === idOfCollidedUser).data.position;\n      this.localUser.position = findCollisionPoint(newPosition, collidedUser);\n    }\n\n    updateData() {\n      var _a;\n\n      let user = (_a = this.untransformedData) === null || _a === void 0 ? void 0 : _a.find(user => user.user_id === this.localUser.id);\n\n      if (user) {\n        user.data.position = this.localUser.position;\n        user.data.direction = this.localUser.direction;\n        let transformedData = transformData(this.untransformedData, this.localUser.id);\n        this.data = transformedData;\n      }\n    }\n\n    updateDrags() {\n      if (Math.abs(this.localUser.velocity) < 0.025) {\n        this.localUser.velocity = 0;\n        this.localUser.drag = 0;\n      } else this.localUser.drag = this.localUser.velocity / 30;\n\n      if (Math.abs(this.localUser.angularVelocity) < 0.001) {\n        this.localUser.angularVelocity = 0;\n        this.localUser.angularDrag = 0;\n      } else this.localUser.angularDrag = this.localUser.angularVelocity / 30;\n    } // addDrags(this: RoomViewComponent) {\n    //   let change = Math.sign(this.localUser.velocity) == -1\n    //     ? this.localUser.drag\n    //     : -this.localUser.drag;\n    //   let angularChange = Math.sign(this.localUser.angularVelocity) == -1\n    //     ? this.localUser.angularDrag\n    //     : -this.localUser.angularDrag;\n    //   const differentSigns = (newVelocity: number) => Math.sign(newVelocity - change) != Math.sign(newVelocity);\n    //   let newVelocity = this.localUser.velocity + change;\n\n\n    addDrags() {\n      this.localUser.velocity -= this.localUser.drag;\n      this.localUser.angularVelocity -= this.localUser.angularDrag;\n    }\n\n    sendMessage() {\n      var _a;\n\n      let position = this.localUser.position;\n      let direction = this.localUser.direction;\n      (_a = this.webSocketService.webSocket) === null || _a === void 0 ? void 0 : _a.next({\n        type: 'move',\n        new_position: position,\n        user_id: this.localUser.id\n      });\n    }\n\n    onLocalUserMoved(eventType) {// switch (eventType) {\n      //   case 'positionChange':\n      //     this.sendPositionChangeMessage();\n      //     break;\n      //   case 'directionChange':\n      //     this.sendDirectionChangeMessage();\n      //     break;\n      //   default:\n      //     break;\n      // }\n    }\n\n    onMessage(event) {\n      console.log(event);\n    }\n\n    ngOnInit() {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        var _a, _b, _c, _d;\n\n        _this2.data = [];\n        yield _this2.webSocketService.init(); // Send an initial message\n\n        let initialPosition = Object.assign({}, _this2.localUser.position);\n        (_a = _this2.webSocketService.webSocket) === null || _a === void 0 ? void 0 : _a.subscribe();\n        (_b = _this2.webSocketService.webSocket) === null || _b === void 0 ? void 0 : _b.next({\n          action: 'join',\n          initial_position: initialPosition,\n          user_id: _this2.localUser.id,\n          request_id: _this2.localUser.id\n        }); // Get initial data\n\n        _this2.animationId = requestAnimationFrame(_this2.refreshRoomView.bind(_this2));\n\n        _this2.roomDataService.getInitialData().subscribe(res => {\n          let data = res.data;\n          _this2.untransformedData = res.data;\n          let transformedData = transformData(data, _this2.localUser.id);\n          _this2.data = transformedData;\n\n          _this2.loadProfiles();\n        });\n\n        _this2.refreshRoomView();\n\n        (_c = _this2.changeEventEmitter) === null || _c === void 0 ? void 0 : _c.subscribe(eventType => _this2.onLocalUserMoved(eventType));\n        (_d = _this2.webSocketService.webSocket) === null || _d === void 0 ? void 0 : _d.subscribe(msg => _this2.onMessage(msg));\n      })();\n    }\n\n  }\n\n  RoomViewComponent.ɵfac = function RoomViewComponent_Factory(t) {\n    return new (t || RoomViewComponent)(i0.ɵɵdirectiveInject(i1.RoomDataService), i0.ɵɵdirectiveInject(i2.UserDataService), i0.ɵɵdirectiveInject(i3.WebSocketService), i0.ɵɵdirectiveInject(i4.WindowService));\n  };\n\n  RoomViewComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: RoomViewComponent,\n    selectors: [[\"app-room-view\"]],\n    viewQuery: function RoomViewComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.roomView = _t.first);\n      }\n    },\n    hostBindings: function RoomViewComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"beforeunload\", function RoomViewComponent_beforeunload_HostBindingHandler() {\n          return ctx.onUnload();\n        }, false, i0.ɵɵresolveWindow)(\"keydown\", function RoomViewComponent_keydown_HostBindingHandler($event) {\n          return ctx.onKeyDown($event);\n        }, false, i0.ɵɵresolveWindow)(\"keyup\", function RoomViewComponent_keyup_HostBindingHandler($event) {\n          return ctx.onKeyUp($event);\n        }, false, i0.ɵɵresolveWindow);\n      }\n    },\n    decls: 6,\n    vars: 7,\n    consts: [[\"xmlns\", \"http://www.w3.org/2000/svg\", \"height\", \"50\", \"preserveAspectRatio\", \"xMidYMid\"], [4, \"ngIf\"], [\"roomView\", \"\"], [\"class\", \"user\", 3, \"id\", 4, \"ngFor\", \"ngForOf\"], [\"x\", \"0\", \"y\", \"0\", \"width\", \"25\", \"height\", \"25\", 3, \"id\", 4, \"ngFor\", \"ngForOf\"], [\"x\", \"0\", \"y\", \"0\", \"width\", \"25\", \"height\", \"25\", 3, \"id\"], [\"width\", \"25\", \"height\", \"25\"], [1, \"user\", 3, \"id\"]],\n    template: function RoomViewComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵnamespaceSVG();\n        i0.ɵɵelementStart(0, \"svg\", 0)(1, \"defs\");\n        i0.ɵɵtemplate(2, RoomViewComponent__svg_ng_container_2_Template, 2, 1, \"ng-container\", 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(3, \"g\", null, 2);\n        i0.ɵɵtemplate(5, RoomViewComponent__svg_circle_5_Template, 1, 8, \"circle\", 3);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattributeInterpolate2(\"viewBox\", \"0 0 \", ctx.getDimensions().width, \" \", ctx.getDimensions().height, \"\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.userProfiles);\n        i0.ɵɵadvance(1);\n        i0.ɵɵattributeInterpolate3(\"transform\", \"rotate(\", -(ctx.localUser.direction || 0), \" \", ctx.getCenterLocation().x, \" \", ctx.getCenterLocation().y, \")\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngForOf\", ctx.data);\n      }\n    },\n    directives: [i5.NgIf, i5.NgForOf],\n    styles: [\"[_nghost-%COMP%]{width:100vw;height:100vh;position:absolute;left:0;top:0;z-index:-1}[_nghost-%COMP%]   svg[_ngcontent-%COMP%]{width:inherit;height:inherit}\"]\n  });\n  return RoomViewComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}